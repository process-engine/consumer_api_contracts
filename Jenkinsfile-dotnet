#!/usr/bin/env groovy

@Library('jenkins_shared-libraries@v1.2.0') _

def cleanup_workspace() {
  cleanWs()
  dir("${env.WORKSPACE}@tmp") {
    deleteDir()
  }
  dir("${env.WORKSPACE}@script") {
    deleteDir()
  }
  dir("${env.WORKSPACE}@script@tmp") {
    deleteDir()
  }
}

def buildIsRequired = true

pipeline {
  agent {
    docker {
      image 'microsoft/dotnet:2.1-sdk'
    }
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '20', artifactNumToKeepStr: '20'))
  }
  environment {
    HOME = "$WORKSPACE"
  }

  stages {
    stage('Check if build is required') {
      steps {
        script {
          // Taken from https://stackoverflow.com/questions/37755586/how-do-you-pull-git-committer-information-for-jenkins-pipeline
          sh 'git --no-pager show -s --format=\'%an\' > commit-author.txt'
          def commitAuthorName = readFile('commit-author.txt').trim()

          def ciAdminName = "admin" // jenkins will set this name after every restart, so we need to look out for this.
          def ciUserName = "process-engine-ci"

          echo(commitAuthorName)
          echo("Commiter is process-engine-ci: ${commitAuthorName == ciUserName || commitAuthorName == ciAdminName}")

          buildIsRequired = commitAuthorName != ciAdminName && commitAuthorName != ciUserName

          if (!buildIsRequired) {
            echo("Commit was made by process-engine-ci. Skipping build.")
          }
        }
      }
    }
    stage('prepare') {
      when {
        expression {buildIsRequired == true}
      }
      steps {
        dir('dotnet') {
          sh('dotnet --version')
          sh('dotnet restore src')

          script {
            PACKAGE_VERSION = nuGetTools.getPackageVersionFromCSProjFile(
              fileName: 'src/ProcessEngine.ConsumerAPI.Contracts.csproj',
            );

            ALLOW_OVERRIDE_OF_PUBLISHED = false;

            if (BRANCH_NAME != 'master') {

              ALLOW_OVERRIDE_OF_PUBLISHED = true;

              def escaped_branch_name = BRANCH_NAME
                .replace('/', '-')
                .replace('_', '-');

              def new_version = "${PACKAGE_VERSION}-${escaped_branch_name}";

              PACKAGE_VERSION = new_version;

              nuGetTools.setPackageVersionInCSProjFile(
                fileName: 'dotnet/src/ProcessEngine.ConsumerAPI.Contracts.csproj',
                newVersion: new_version,
              );
            }
          }
        }
      }
    }
    stage('build') {
      when {
        expression {buildIsRequired == true}
      }
      steps {
        dir('dotnet') {
          sh('dotnet --version')
          sh('dotnet build --configuration Release src')
        }
      }
    }
    stage('publish') {
      when {
        expression {buildIsRequired == true}
      }
      steps {
        dir('dotnet') {

          sh('dotnet --version')
          withCredentials([string(credentialsId: 'myget_process_engine_public_feed_token', variable: 'PROCESS_ENGINE_PUBLIC')]) {
            script {

              echo "Package version is ${PACKAGE_VERSION}.";

              def packageWasAlreadyPublished = nuGetTools.isNuGetPackagePublished(
                nuGetFeedURL: "https://5minds.myget.org/F/process_engine_public/api/v3/index.json",
                package: "ProcessEngine.ConsumerAPI.Contracts",
                version: PACKAGE_VERSION,
                nuGetToken: PROCESS_ENGINE_PUBLIC,
              );

              def shouldPublish = ALLOW_OVERRIDE_OF_PUBLISHED || !packageWasAlreadyPublished;
              if (packageWasAlreadyPublished) {
                if (ALLOW_OVERRIDE_OF_PUBLISHED) {
                  echo "Package version was already published, overriding version."
                } else {
                  echo "Package version was already published, skipping publish.";
                }
              }

              if (shouldPublish) {
                sh("dotnet nuget push src/bin/Release/ProcessEngine.ConsumerAPI.Contracts.*.nupkg --api-key $PROCESS_ENGINE_PUBLIC --source https://5minds.myget.org/F/process_engine_public/api/v2");
              }
            }
          }
        }
      }
    }
    stage('cleanup') {
      when {
        expression {buildIsRequired == true}
      }
      steps {
        script {
          // this stage just exists, so the cleanup-work that happens in the post-script
          // will show up in its own stage in Blue Ocean
          sh(script: ':', returnStdout: true);
        }
      }
    }
  }
  post {
    always {
      script {
        cleanup_workspace();
      }
    }
  }
}
